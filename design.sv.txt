// Instruction Memory
module instruction_memory (input [31:0] addr,output reg [31:0] data);
  reg[31:0] IMemory [0:1023]; //4K instruction memory
  initial begin
  IMemory[0]   = 32'h01094020; // add $t0, $t1, $t2   
  IMemory[4]   = 32'h012b6022; // sub $t3, $t4, $t5  
  IMemory[8]   = 32'h8c050000; // lw $a1, 0($v0)
  IMemory[12]  = 32'hac060004; // sw $a2, 4($v0)
  IMemory[16]  = 32'h00a22020; // add $a0, $a1, $v0
  IMemory[20]  = 32'h00c32822; // sub $a2, $a3, $v1
  IMemory[24]  = 32'h00000000; // nop (No operation)
  IMemory[28]  = 32'h8c070004; // lw $a3, 4($v0)
  IMemory[32]  = 32'hac070008; // sw $a3, 8($v0)
  IMemory[36]  = 32'h10a40004; // beq $a1, $a0, 4
  IMemory[40]  = 32'h016c6020; // add $t0, $t3, $t4
  IMemory[44]  = 32'h01352022; // sub $t3, $t4, $s0
  IMemory[48]  = 32'h8c030008; // lw $v1, 8($a0)
  IMemory[52]  = 32'hac04000C; // sw $a0, 12($v0)
  IMemory[56]  = 32'h14a50004; // beq $a1, $a0, 4


    

    
  end
    always @(addr) begin
    case(addr)
      00 : data = IMemory[0]; 
      04 : data = IMemory[4];
      08 : data = IMemory[8];
      12 : data = IMemory[12];
      16 : data = IMemory[16];
      20 : data = IMemory[20];
      24 : data = IMemory[24];
      28 : data = IMemory[28];
      32 : data = IMemory[32];
      36 : data = IMemory[36];
      40 : data = IMemory[40];
      44 : data = IMemory[44];
      48 : data = IMemory[48];
      52 : data = IMemory[52];
      56 : data = IMemory[56];
    endcase
  end

endmodule

// ALU Controller
module ALU_Controller (
  input [5:0] func,
  input [1:0] ALU_Op,
  output reg [3:0] ALU_Control
);
  always @(*) begin
    case(ALU_Op)
      2'b00: ALU_Control = 4'b0010; // ADD
      2'b01: ALU_Control = 4'b0110; // SUB
      2'b10: begin
        case(func)
          6'b100000: ALU_Control = 4'b0010; // ADD
          6'b100010: ALU_Control = 4'b0110; // SUB
          default: ALU_Control = 4'b0000; // NOP
        endcase
      end
      default: ALU_Control = 4'b0000; // Default to NOP
    endcase
  end
endmodule

// Main Control Unit
module Main_Control_Unit (
  input [31:0] instruction_mc_code,
  output reg branch,
  output reg MemRead,
  output reg MemtoReg,
  output reg MemWrite,
  output reg ALUSRC,
  output reg RegWrite,
  output reg RegDst,
  output reg [1:0] ALUOp
);
  reg [5:0] op_code;
  always @(*) begin
    op_code = instruction_mc_code[31:26];
    case(op_code)
      6'b000000: begin // R-format
        RegDst = 1;
        branch = 0;
        ALUSRC = 0;
        RegWrite = 1;
        MemRead = 0;
        MemWrite = 0;
        MemtoReg = 0;
        ALUOp = (instruction_mc_code[5:0] == 6'b100000) ? 2'b00 : 2'b01; // ADD or SUB
      end
      6'b100011: begin // lw
        RegDst = 0;
        branch = 0;
        ALUSRC = 1;
        RegWrite = 1;
        MemRead = 1;
        MemWrite = 0;
        MemtoReg = 1;
        ALUOp = 2'b00; // ADD
      end
      6'b101011: begin // sw
       
        
        branch = 0;
        ALUSRC = 1;
        RegWrite = 0;
        MemRead = 0;
        MemWrite = 1;
        ALUOp = 2'b00; // ADD
      end
      6'b000100: begin // beq
        
        
        branch = 1;
        ALUSRC = 0;
        RegWrite = 0;
        MemRead = 0;
        MemWrite = 0;
        ALUOp = 2'b01; // SUB
      end
      default: begin // Default case
        RegDst = 0;
        branch = 0;
        ALUSRC = 0;
        RegWrite = 0;
        MemRead = 0;
        MemWrite = 0;
        MemtoReg = 0;
        ALUOp = 2'b00;
      end
    endcase
  end
endmodule

// ALU
module ALU (
  input [31:0] data1,
  input [31:0] data2,
  input [3:0] ALU_Control,
  output reg zero_flag,
  output reg [31:0] result
);
  always @(*) begin
    zero_flag = 0;
    case(ALU_Control)
      4'b0010: result = data1 + data2; // ADD
      4'b0110: result = data1 - data2; // SUB
      default: result = 32'b0;
    endcase
    if (result == 0)
      zero_flag = 1;
  end
endmodule

// Data Memory
module data_memory (input [31:0] addr,input [31:0] wdata,input we,input mem_read,output reg [31:0] rdata);
  reg [31:0] memdata [0:4096]; //16K Data Memory

  always @(*) begin
    if (we)
      memdata[addr] <= wdata;
    else if (mem_read)
      rdata = memdata[addr];
    else
      rdata = 32'b0;
  end
endmodule

// Registers
module registers (
  input [4:0] rs, rt, rd,
  input [31:0] write_data,
  input RegWrite,
  output reg [31:0] read_data1, read_data2
);
  reg [31:0] reg_file [31:0];
  initial begin
   reg_file[0] = 32'd2;
    reg_file[1] = 32'd5;
    reg_file[2] = 32'd1;
    reg_file[3] = 32'd4;
    reg_file[4] = 32'd3;
    reg_file[5] = 32'd0;
    reg_file[6] = 32'd1;
    reg_file[7] = 32'd2;
    reg_file[8] = 32'd3;
    reg_file[9] = 32'd4;
    reg_file[10] = 32'd5;
    reg_file[11] = 32'd6;
    reg_file[12] = 32'd7;
    reg_file[13] = 32'd8;
    reg_file[14] = 32'd9;
    reg_file[15] = 32'd10;
    reg_file[16] = 32'd11;
    reg_file[17] = 32'd11;
    reg_file[18] = 32'd13;
    reg_file[19] = 32'd14;
    reg_file[20] = 32'd15;
    reg_file[21] = 32'd16;
    reg_file[22] = 32'd17;
    reg_file[23] = 32'd18;
    reg_file[24] = 32'd19;
    reg_file[25] = 32'd20;
    reg_file[26] = 32'd21;
    reg_file[28] = 32'd22;
    reg_file[29] = 32'd23;
    reg_file[30] = 32'd24;
    reg_file[31] = 32'd25;

  end
  
  always @(*) begin
    read_data1 = reg_file[rs];
    read_data2 = reg_file[rt];
  end
	
  
  
  
  always @(posedge RegWrite) begin
    if (RegWrite)
      reg_file[rd] <= write_data;
  end
endmodule

// Program Counter
module program_counter (
  input [31:0] current_pc,
  output reg [31:0] pc_of_next_instruction
);
  always @(*) begin
    pc_of_next_instruction = current_pc + 4;
  end
endmodule

// Sign Extend
module sign_extend (
  input [15:0] offset,
  output reg [31:0] sign_extended
);
  always @(*) begin
    sign_extended = {{16{offset[15]}}, offset};
  end
endmodule

// MIPS Processor
module MIPS_Processor (
  input clk, reset,
  output reg[31:0] pc_out, output[31:0] result
);
  reg [31:0] pc, pc_next;
  wire [31:0] instruction_mc_code, read_data1, read_data2, sign_extended, result_of_ALU, branch_target;
  wire [1:0] ALUOp;
  wire zero, branch_taken;
  reg [31:0] write_data;

  always @(posedge clk or posedge reset) begin
    if (reset)
      pc <= 32'd0;
    else
      pc <= pc_next;
  end

  // Instruction Memory
  instruction_memory instr_mem(pc, instruction_mc_code);

  // Control Unit
  Main_Control_Unit main_ctrl(
    .instruction_mc_code(instruction_mc_code), 
    .branch(branch), 
    .MemRead(MemRead), 
    .MemtoReg(MemtoReg), 
    .MemWrite(MemWrite), 
    .ALUSRC(ALUSRC), 
    .RegWrite(RegWrite), 
    .RegDst(RegDst), 
    .ALUOp(ALUOp)
  );
  //ALU CONTROLLER
  ALU_Controller AR(instruction_mc_code[5:0],ALUOp,ALU_Control);
  
  // Register File
  registers reg_file(
    .rs(instruction_mc_code[25:21]), 
    .rt(instruction_mc_code[20:16]), 
    .rd(RegDst ? instruction_mc_code[15:11] : instruction_mc_code[20:16]), 
    .write_data(write_data), 
    .RegWrite(RegWrite), 
    .read_data1(read_data1), 
    .read_data2(read_data2)
  );

  // Sign Extension
  sign_extend sign_ext(.offset(instruction_mc_code[15:0]), .sign_extended(sign_extended));

  // ALU
  ALU alu(
    .data1(read_data1), 
    .data2(ALUSRC ? sign_extended : read_data2), 
    .ALU_Control(ALU_Control), 
    .zero_flag(zero), 
    .result(result_of_ALU)
  );

  // Data Memory
  data_memory data_mem(
    .addr(result_of_ALU), 
    .wdata(read_data2), 
    .we(MemWrite), 
    .mem_read(MemRead), 
    .rdata(result)
  );

  // Branch Target Calculation
  assign branch_target = pc + 4 + (sign_extended << 2);
  assign branch_taken = branch && zero;

  // Determine Next PC
  always @(*) begin
    if (branch_taken)
      pc_next = branch_target;
    else
      pc_next = pc + 4;
  end

  // Write Back Logic
  always @(*) begin
    write_data = (MemtoReg ? result : result_of_ALU);
  end

   assign pc_out = pc_next;
  assign result = result_of_ALU;
endmodule
